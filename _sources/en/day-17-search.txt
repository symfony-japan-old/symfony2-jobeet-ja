Day 17: Search
==============

.. include:: common/original.rst.inc

In day 14, we added some feeds to keep Jobeet users up-to-date with new job posts. Today will help you to improve the user experience by implementing the latest main feature of the Jobeet website: the search engine.

The Technology
--------------

Today, we want to add a search engine to Jobeet, and the Zend Framework provides a great library, called Zend Lucene, which is a port of the well-know Java Lucene project. Instead of creating yet another search engine for Jobeet, which is quite a complex task, we will use Zend Lucene.
Today is not a tutorial about the Zend Lucene library, but how to integrate it into the Jobeet website; or more generally, how to integrate third-party libraries into a symfony project. If you want more information about this technology, please refer to the Zend Lucene documentation.

Installing and Configuring the Zend Framework
---------------------------------------------

The Zend Lucene library is part of the Zend Framework. We will only install the Zend Framework into the vendor/ directory, alongside the symfony framework itself.
First, download the Zend Framework and unzip the files so that you have a vendor/Zend/directory. Keep in mind that the 2.*  versions of Zend Framework do not have Lucene library integrated, so don’t download any of them for this tutorial.

.. note::

   The following explanations have been tested with the 1.12.3 version of the Zend Framework.

.. image:: /images/Day-17-zend.jpg

You can clean up the directory by removing everything but the following files and directories:

* Exception.php
* Loader/
* Loader.php
* Search/

Then, add the following code to the autoload.php file to provide a simple way to register the Zend autoloader.

app/autoload.php

.. code-block:: php

   // ...

   set_include_path(__DIR__.'/../vendor'.PATH_SEPARATOR.get_include_path());
   require_once __DIR__.'/../vendor/Zend/Loader/Autoloader.php';
   Zend_Loader_Autoloader::getInstance();

   return $loader;

Indexing
--------

The Jobeet search engine should be able to return all jobs matching keywords entered by the user. Before being able to search anything, an index has to be built for the jobs; for Jobeet, it will be stored in a new directory you will create, /web/data/ .
Zend Lucene provides two methods to retrieve an index depending whether one already exists or not. Let’s create helper methods in the Job entity class that returns an existing index or creates a new one for us:

src/Ibw/JobeetBundle/Entity/Job.php

.. code-block:: php

   // ...

   class Job
   {
       // ...

       static public function getLuceneIndex()
       {
           if (file_exists($index = self::getLuceneIndexFile())) {
               return \Zend_Search_Lucene::open($index);
           }

           return \Zend_Search_Lucene::create($index);
       }

       static public function getLuceneIndexFile()
       {
           return __DIR__.'/../../../../web/data/job.index';
       }
   }

Each time a job is created or updated, the index must be updated. Edit the ORM file to update the index whenever a job is serialized to the database:

src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orm.yml

.. code-block:: yaml

   # ...
       # ...
       lifecycleCallbacks:
           # ...
           postPersist: [ upload, updateLuceneIndex ]
           postUpdate: [ upload, updateLuceneIndex ]
           # ...

Now, run the generate:entities command, so that the updateLuceneIndex() method to be generated by Doctrine inside the Job class:

.. code-block:: bash

   $ php app/console doctrine:generate:entities IbwJobeetBundle

Then, edit the updateLuceneIndex() method that does the actual work:

src/Ibw/JobeetBundle/Entity/Job.php

.. code-block:: php

   class Job
   {
       // ...

       public function updateLuceneIndex()
       {
           $index = self::getLuceneIndex();

           // remove existing entries
           foreach ($index->find('pk:'.$this->getId()) as $hit)
           {
             $index->delete($hit->id);
           }

           // don't index expired and non-activated jobs
           if ($this->isExpired() || !$this->getIsActivated())
           {
             return;
           }

           $doc = new \Zend_Search_Lucene_Document();

           // store job primary key to identify it in the search results
           $doc->addField(\Zend_Search_Lucene_Field::Keyword('pk', $this->getId()));

           // index job fields
           $doc->addField(\Zend_Search_Lucene_Field::UnStored('position', $this->getPosition(), 'utf-8'));
           $doc->addField(\Zend_Search_Lucene_Field::UnStored('company', $this->getCompany(), 'utf-8'));
           $doc->addField(\Zend_Search_Lucene_Field::UnStored('location', $this->getLocation(), 'utf-8'));
           $doc->addField(\Zend_Search_Lucene_Field::UnStored('description', $this->getDescription(), 'utf-8'));

           // add job to the index
           $index->addDocument($doc);
           $index->commit();
       }
   }

As Zend Lucene is not able to update an existing entry, it is removed first if the job already exists in the index.
Indexing the job itself is simple: the primary key is stored for future reference when searching jobs and the main columns (position, company, location, and description) are indexed but not stored in the index as we will use the real objects to display the results.
We also need create a deleteLuceneIndex() method to remove the entry of the deleted job from the index. As we did for the update, we will do for delete. Start by adding the deleteLuceneIndex() method to postRemove section of the ORM file:

src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orm.yml

.. code-block:: yaml

   # ...
       # ...
       lifecycleCallbacks:
           # ...
           postRemove: [ removeUpload, deleteLuceneIndex ]

Again, run the command for generating entities.
Now, go to entity file and implement the deleteLuceneIndex() method:

src/Ibw/JobeetBundle/Entity/Job.php

.. code-block:: php

   class Job
   {
       // ...

       public function deleteLuceneIndex()
       {
           $index = self::getLuceneIndex();

           foreach ($index->find('pk:'.$this->getId()) as $hit) {
               $index->delete($hit->id);
           }
       }
   }

As the index is modified from the command line and also from the web, you must change the index directory permissions accordingly depending on your configuration:

.. code-block:: bash

   $ chmod -R 777 web/data

Now that we have everything in place, you can reload the fixture data to index them:

.. code-block:: bash

   $ php app/console doctrine:fixtures:load

The Search
----------

Implementing the search is a piece of cake. First, create a route:

wrc/Ibw/JobeetBundle/Resources/config/routing/job.yml

.. code-block:: yaml

   # ...

   ibw_job_search:
       pattern: /search
       defaults: { _controller: "IbwJobeetBundle:Job:search" }

And the corresponding action:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   namespace Ibw\JobeetBundle\Controller;

   use Symfony\Component\HttpFoundation\Request;
   use Symfony\Bundle\FrameworkBundle\Controller\Controller;
   use Ibw\JobeetBundle\Entity\Job;
   use Ibw\JobeetBundle\Form\JobType;

   class JobController extends Controller
   {
       // ...

       public function searchAction(Request $request)
       {
           $em = $this->getDoctrine()->getManager();
           $query = $this->getRequest()->get('query');

           if(!$query) {
               return $this->redirect($this->generateUrl('ibw_job'));
           }

           $jobs = $em->getRepository('IbwJobeetBundle:Job')->getForLuceneQuery($query);

           return $this->render('IbwJobeetBundle:Job:search.html.twig', array('jobs' => $jobs));
       }
   }

Inside the searcAction(), the user is forwarded to the index action of the JobController if the query request does not exist or is empty.
The template is also quite straightforward:

src/Ibw/JobeetBundle/Resources/views/Job/search.html.twig

.. code-block:: html+jinja

   {% extends 'IbwJobeetBundle::layout.html.twig' %}

   {% block stylesheets %}
       {{ parent() }}
       <link rel="stylesheet" href="{{ asset('bundles/ibwjobeet/css/jobs.css') }}" type="text/css" media="all" />
   {% endblock %}

   {% block content %}
       <div id="jobs">
           {% include 'IbwJobeetBundle:Job:list.html.twig' with {'jobs': jobs} %}
       </div>
   {% endblock %}

The search itself is delegated to the getForLuceneQuery() method:

src/Ibw/JobeetBundle/Repository/JobRepository.php

.. code-block:: php

   namespace Ibw\JobeetBundle\Repository;

   use Doctrine\ORM\EntityRepository;
   use Ibw\JobeetBundle\Entity\Job;

   class JobRepository extends EntityRepository
   {
       // ...

       public function getForLuceneQuery($query)
       {
           $hits = Job::getLuceneIndex()->find($query);

           $pks = array();
           foreach ($hits as $hit)
           {
             $pks[] = $hit->pk;
           }

           if (empty($pks))
           {
             return array();
           }

           $q = $this->createQueryBuilder('j')
               ->where('j.id IN (:pks)')
               ->setParameter('pks', $pks)
               ->andWhere('j.is_activated = :active')
               ->setParameter('active', 1)
               ->setMaxResults(20)
               ->getQuery();

           return $q->getResult();
       }
   }

After we get all results from the Lucene index, we filter out the inactive jobs, and limit the number of results to 20.
To make it work, update the layout:

.. code-block:: html+jinja

   <!-- ... -->
       <!-- ... -->
           <div class="search">
               <h2>Ask for a job</h2>
               <form action="{{ path('ibw_job_search') }}" method="get">
                   <input type="text" name="query" value="{{ app.request.get('query') }}" id="search_keywords" />
                   <input type="submit" value="search" />
                   <div class="help">
                       Enter some keywords (city, country, position, ...)
                   </div>
               </form>
           </div>
       <!-- ... -->
   <!-- ... -->

Unit Tests
----------

What kind of unit tests do we need to create to test the search engine? We obviously won’t test the Zend Lucene library itself, but its integration with the Job class.
Add the following test at the end of the JobRepositoryTest.php file:

src/Ibw/JobeetBundle/Tests/Repository/JobRepositoryTest.php

.. code-block:: php

   // ...
   use Ibw\JobeetBundle\Entity\Job;

   class JobRepositoryTest extends WebTestCase
   {
       // ...

       public function testGetForLuceneQuery()
       {
           $em = static::$kernel->getContainer()
               ->get('doctrine')
               ->getManager();

           $job = new Job();
           $job->setType('part-time');
           $job->setCompany('Sensio');
           $job->setPosition('FOO6');
           $job->setLocation('Paris');
           $job->setDescription('WebDevelopment');
           $job->setHowToApply('Send resumee');
           $job->setEmail('jobeet@example.com');
           $job->setUrl('http://sensio-labs.com');
           $job->setIsActivated(false);

           $em->persist($job);
           $em->flush();

           $jobs = $em->getRepository('IbwJobeetBundle:Job')->getForLuceneQuery('FOO6');
           $this->assertEquals(count($jobs), 0);

           $job = new Job();
           $job->setType('part-time');
           $job->setCompany('Sensio');
           $job->setPosition('FOO7');
           $job->setLocation('Paris');
           $job->setDescription('WebDevelopment');
           $job->setHowToApply('Send resumee');
           $job->setEmail('jobeet@example.com');
           $job->setUrl('http://sensio-labs.com');
           $job->setIsActivated(true);

           $em->persist($job);
           $em->flush();

           $jobs = $em->getRepository('IbwJobeetBundle:Job')->getForLuceneQuery('position:FOO7');
           $this->assertEquals(count($jobs), 1);
           foreach ($jobs as $job_rep) {
               $this->assertEquals($job_rep->getId(), $job->getId());
           }

           $em->remove($job);
           $em->flush();

           $jobs = $em->getRepository('IbwJobeetBundle:Job')->getForLuceneQuery('position:FOO7');

           $this->assertEquals(count($jobs), 0);
       }
   }

We test that a non activated job, or a deleted one does not show up in the search results; we also check that jobs matching the given criteria do show up in the results.

Tasks
-----

Eventually, we need to update the JobeetCleanup task to cleanup the index from stale entries (when a job expires for example) and optimize the index from time to time:

src/Ibw/JobeetBundle/Command/JobeetCleanupCommand.php

.. code-block:: php

   // ...
   use  Ibw\JobeetBundle\Entity\Job;

   class JobeetCleanupCommand extends ContainerAwareCommand
   {
       // ...

       protected function execute(InputInterface $input, OutputInterface $output)
       {
           $days = $input->getArgument('days');

           $em = $this->getContainer()->get('doctrine')->getManager();

           // cleanup Lucene index
           $index = Job::getLuceneIndex();

           $q = $em->getRepository('IbwJobeetBundle:Job')->createQueryBuilder('j')
             ->where('j.expires_at < :date')
             ->setParameter('date',date('Y-m-d'))
             ->getQuery();

           $jobs = $q->getResult();
           foreach ($jobs as $job)
           {
             if ($hit = $index->find('pk:'.$job->getId()))
             {
               $index->delete($hit->id);
             }
           }

           $index->optimize();

           $output->writeln('Cleaned up and optimized the job index');

           // Remove stale jobs
           $nb = $em->getRepository('IbwJobeetBundle:Job')->cleanup($days);

           $output->writeln(sprintf('Removed %d stale jobs', $nb));
       }
   }

The task removes all expired jobs from the index and then optimizes it thanks to the Zend Lucene built-in optimize() method.
Along this day, we implemented a full search engine with many features in less than an hour. Every time you want to add a new feature to your projects, check that it has not yet been solved somewhere else.
Tomorrow we will use some unobtrusive JavaScripts to enhance the responsiveness of the search engine by updating the results in real-time as the user types in the search box. Of course, this will be the occasion to talk about how to use AJAX with symfony.

.. include:: common/license.rst.inc
