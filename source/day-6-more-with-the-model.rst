6日目: モデルの続き
==========================
Day 6: More with the Model
==========================

.. include:: common/original.rst.inc

Doctrine クエリーオブジェクト
-----------------------------
The Doctrine Query Object
-------------------------

2日目の要件として、「トップページでは、ユーザーは最新の有効な求人を閲覧します」としました。しかし、現在はすべての求人が、アクティブであるかに関わらず表示されています。
From the second day’s requirements: “On the homepage, the user sees the latest active jobs”. But as of now, all jobs are displayed, whether they are active or not:


src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

   class JobController extends Controller
   {
       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $entities = $em->getRepository('IbwJobeetBundle:Job')->findAll();

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'entities' => $entities
           ));

    // ...
   }

アクティブな求人は30日前以内に投稿されたものです。 ``$entities = $em->getRepository('IbwJobeetBundle')->findAll()`` メソッドは、すべての求人を取得するために、データベースへのリクエストを行います。
私たちはどんな条件も指定していません。そのため、すべてのレコードがデータベースから取り出されてしまいます。
それでは、アクティブな求人のみを選択するために、それを変更してみましょう：
An active job is one that was posted less than 30 days ago. The $entities = $em->getRepository('IbwJobeetBundle')->findAll() method will make a request to the database to get all the jobs.
 We are not specifying any condition, which means that all the records are retrieved from the database.
Let’s change it to only select active jobs:

.. code-block:: php

   public function indexAction()
   {
       $em = $this->getDoctrine()->getManager();

       $query = $em->createQuery(
           'SELECT j FROM IbwJobeetBundle:Job j WHERE j.created_at > :date'
       )->setParameter('date', date('Y-m-d H:i:s', time() - 86400 * 30));
       $entities = $query->getResult();

       return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
           'entities' => $entities
       ));
   }

Debugging Doctrine generated SQL
--------------------------------

時には、それは Doctrine によって生成されたSQLを参照するには大きな助けとなります。
例えば、期待通りに動作しないクエリをデバッグします。 （：//jobeet.local/app_dev.php HTTP）のdev環境では、symfonyはWebデバッグツールバーのおかげで、あなたが必要なすべての情報がブラウザ上で快適に利用できます。
Sometimes, it is of great help to see the SQL generated by Doctrine; for instance, to debug a query that does not work as expected.
In the dev environment, thanks to the Symfony Web Debug Toolbar, all the information you need is available within the comfort of your browser (http://jobeet.local/app_dev.php):

.. image:: /images/Day-6-web-debug-toolbar.png

Object Serialization
--------------------

上記のコードは動作している場合でも、それが2日目から考慮し、いくつかの要件をとらないように、それは完璧にはほど遠いです。「ユーザーはアクティベートを再や余分な30日間の仕事の有効性を拡張するために戻って来ることができる.. "。
しかし、上記のコードだけはcreated_atの値に依存しており、この列は作成日を格納しているため、私たちは上記の要件を満たすことができないように。
あなたは私たちが3日目に記述したデータベーススキーマを覚えていれば、私たちもexpires_atカラムを定義しました。この値は、フィクスチャファイルに設定されていない場合、現在、それは常に空のままである。ジョブが作成されるときには、自動的に現在の日付から30日後に設定することができる。
Doctrineのオブジェクトがデータベースにシリアライズされる前に自動的に何かをする必要があるときに、先ほどはcreated_atカラムの行ったように、あなたは、オブジェクトをデータベースにマッピングするファイル内のライフサイクルコールバックに新しいアクションを追加することができます。
Even if the code above works, it is far from perfect as it does not take into account some requirements from Day 2: “A user can come back to re-activate or extend the validity of the job for an extra 30 days..”.
But as the above code only relies on the created_at value, and because this column stores the creation date, we cannot satisfy the above requirement.
If you remember the database schema we have described during Day 3, we also have defined an expires_at column. Currently, if this value is not set in fixture file, it remains always empty. But when a job is created, it can be automatically set to 30 days after the current date.
When you need to do something automatically before a Doctrine object is serialized to the database, you can add a new action to the lifecycle callbacks in the file that maps objects to the database, like we did earlier for the created_at column:

src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orml.yml

.. code-block:: yaml

   # ...
       # ...
       lifecycleCallbacks:
           prePersist: [ setCreatedAtValue, setExpiresAtValue ]
           preUpdate: [ setUpdatedAtValue ]

今、私たちはDoctrineが新しい関数が追加されますので、エンティティクラスを再構築する必要があります。
Now, we have to rebuild the entities classes so Doctrine will add the new function:

.. code-block:: bash

   $ php app/console doctrine:generate:entities IbwJobeetBundle

のsrc / IBW/ JobeetBundle/エンティティ/ Job.phpファイルを開き、新たな付加機能を編集します。
Open the src/Ibw/JobeetBundle/Entity/Job.php file and edit the new added function:

src/Ibw/JobeetBundle/Entity/Job.php

.. code-block:: php

   // ...

   class Job
   {
       // ...

       public function setExpiresAtValue()
       {
           if(!$this->getExpiresAt()) {
               $now = $this->getCreatedAt() ? $this->getCreatedAt()->format('U') : time();
               $this->expires_at = new \DateTime(date('Y-m-d H:i:s', $now + 86400 * 30));
           }
       }
   }

では、アクティブなジョブを選択するためにはcreated_atの代わりにexpires_at列を使用するようにアクションを変更してみましょう：
Now, let’s change the action to use the expires_at column instead of the created_at one to select the active jobs:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $query = $em->createQuery(
               'SELECT j FROM IbwJobeetBundle:Job j WHERE j.expires_at > :date'
       )->setParameter('date', date('Y-m-d H:i:s', time()));
           $entities = $query->getResult();

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'entities' => $entities
           ));
       }

   // ...

More with Fixtures
------------------

データベース内のジョブが数日前に投稿されたばかりのようにブラウザでJobeetのホームページをリフレッシュする、何も変わりません。それではすでに期限切れした求人情報を追加するためにフィクスチャを変更しましょう：
Refreshing the Jobeet homepage in your browser won’t change anything, as the jobs in the database have been posted just a few days ago. Let’s change the fixtures to add a job that is already expired:

src/Ibw/JobeetBundle/DataFixtures/ORM/LoadJobData.php

.. code-block:: php

   // ...

       public function load(ObjectManager $em)
       {
           $job_expired = new Job();
           $job_expired->setCategory($em->merge($this->getReference('category-programming')));
           $job_expired->setType('full-time');
           $job_expired->setCompany('Sensio Labs');
           $job_expired->setLogo('sensio-labs.gif');
           $job_expired->setUrl('http://www.sensiolabs.com/');
           $job_expired->setPosition('Web Developer Expired');
           $job_expired->setLocation('Paris, France');
           $job_expired->setDescription('Lorem ipsum dolor sit amet, consectetur adipisicing elit.');
           $job_expired->setHowToApply('Send your resume to lorem.ipsum [at] dolor.sit');
           $job_expired->setIsPublic(true);
           $job_expired->setIsActivated(true);
           $job_expired->setToken('job_expired');
           $job_expired->setEmail('job@example.com');
           $job_expired->setCreatedAt(new \DateTime('2005-12-01'));

           // ...

           $em->persist($job_expired);
           // ...
       }

   // ...

フィクスチャをリロードし、古いジョブが表示されないことを確認するためにブラウザをリフレッシュします。
Reload the fixtures and refresh your browser to ensure that the old job does not show up:

.. code-block:: bash

   $ php app/console doctrine:fixtures:load

Refactoring
-----------

書いたコードが動作しますが、それはかなり右まだありません。あなたが問題を発見することはできますか？
アクション（コントローラ層）に属していないDoctrineのクエリコードは、Modelレイヤーに所属。 MVCモデルでは、モデルはすべてのビジネスロジックを定義し、Controllerはデータを読み取るモデルのみを呼び出します。コードは、ジョブのコレクションを返すように、のモデルにコードを移動しましょう​​。そのためには、ジョブの実体のカスタムリポジトリクラスを作成する必要がありますし、そのクラスにクエリを追加する。
/src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orm.ymlを開いて、そこに次の行を追加します。
Although the code we have written works fine, it’s not quite right yet. Can you spot the problem?
The Doctrine query code does not belong to the action (the Controller layer), it belongs to the Model layer. In the MVC model, the Model defines all the business logic, and the Controller only calls the Model to retrieve data from it. As the code returns a collection of jobs, let’s move the code to the model. For that we will need to create a custom repository class for Job entity and to add the query to that class.
Open /src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orm.yml and add the following to it:

src/Ibw/JobeetBundle/Resources/config/doctrine/Job.orm.yml

.. code-block:: yaml

   Ibw\JobeetBundle\Entity\Job:
       type: entity
       repositoryClass: Ibw\JobeetBundle\Repository\JobRepository
       # ...

Doctrineは生成し​​実行することで、あなたのためのリポジトリクラスを生成することができます。エンティティが以前に使用したコマンド：
Doctrine can generate the repository class for you by running the generate:entities command used earlier:

.. code-block:: bash

   $ php app/console doctrine:generate:entities IbwJobeetBundle

次に、新しいメソッドを追加 - getActiveJobsを（） - 新規に生成されたリポジトリクラスに。 （それが$ category_idにパラメータを受信した場合、カテゴリによってフィルタリングされた）このメソッドは、expires_atの列でソートアクティブジョブのエンティティのすべてを照会します。
Next, add a new method – getActiveJobs() – to the newly generated repository class. This method will query for all of the active Job entities sorted by the expires_at column (and filtered by category, if it receives the $category_id parameter).

src/Ibw/JobeetBundle/Repository/JobRepository.php

.. code-block:: php

   namespace Ibw\JobeetBundle\Repository;

   use Doctrine\ORM\EntityRepository;

   /**
    * JobRepository
    *
    * This class was generated by the Doctrine ORM. Add your own custom
    * repository methods below.
    */
   class JobRepository extends EntityRepository
   {
       public function getActiveJobs($category_id = null)
       {
           $qb = $this->createQueryBuilder('j')
               ->where('j.expires_at > :date')
               ->setParameter('date', date('Y-m-d H:i:s', time()))
               ->orderBy('j.expires_at', 'DESC');

           if($category_id)
           {
               $qb->andWhere('j.category = :category_id')
                   ->setParameter('category_id', $category_id);
           }

           $query = $qb->getQuery();

           return $query->getResult();
       }
   }

今すぐアクションコードは、アクティブなジョブを取得するために、この新しいメソッドを使用することができます。
Now the action code can use this new method to retrieve the active jobs.

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $entities = $em->getRepository('IbwJobeetBundle:Job')->getActiveJobs();

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'entities' => $entities
           ));
       }

   // ...

*このリファクタリングは、前のコードに比べていくつかの利点があります。
*アクティブなジョブを取得するためのロジックは、それが属するモデル、に今ある
*コントローラーのコードは、より薄く、より読みやすくです
* getActiveJobs（）メソッドは、再利用可能なされている（たとえば別のアクションで）
*モデルコードは現在、テスト可能なユニットであり、

* This refactoring has several benefits over the previous code:
* The logic to get the active jobs is now in the Model, where it belongs
* The code in the controller is thinner and much more readable
* The getActiveJobs() method is re-usable (for instance in another action)
* The model code is now unit testable

ホームページ上のカテゴリー
--------------------------
Categories on the Homepage
--------------------------

二日目の要件によると、私たちは、カテゴリでソートジョブを持っている必要があります。今まで、私たちは考慮に職種を受けていない。要件からはホームページでカテゴリに基づいて表示しなければなりません。まず、少なくとも1つの利用可能な求人からすべてのカテゴリを取得する必要があります。
私たちが仕事をするために行ったようにカテゴリエンティティのリポジトリクラスを作成します。
According to the second day’s requirements we need to have jobs sorted by categories. Until now, we have not taken the job category into account. From the requirements, the homepage must display jobs by category. First, we need to get all categories with at least one active job.
Create a repository class for the Category entity like we did for Job:

src/Ibw/JobeetBundle/Resources/config/doctrine/Category.orm.yml

.. code-block:: yaml

   Ibw\JobeetBundle\Entity\Category:
       type: entity
       repositoryClass: Ibw\JobeetBundle\Repository\CategoryRepository
       #...

リポジトリクラスを生成します。
Generate the repository class:

.. code-block:: bash

   $ php app/console doctrine:generate:entities IbwJobeetBundle

（）メソッドをCategoryRepositoryクラスを開き、getWithJobsを追加します。
Open the CategoryRepository class and add a getWithJobs() method:

src/Ibw/JobeetBundle/Repository/CategoryRepository.php

.. code-block:: php

   namespace Ibw\JobeetBundle\Repository;

   use Doctrine\ORM\EntityRepository;

   /**
    * CategoryRepository
    *
    * This class was generated by the Doctrine ORM. Add your own custom
    * repository methods below.
    */
   class CategoryRepository extends EntityRepository
   {
       public function getWithJobs()
       {
           $query = $this->getEntityManager()->createQuery(
               'SELECT c FROM IbwJobeetBundle:Category c LEFT JOIN c.jobs j WHERE j.expires_at > :date'
           )->setParameter('date', date('Y-m-d H:i:s', time()));

           return $query->getResult();
       }
   }

それに応じてindexアクションを変更します。
Change the index action accordingly:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $categories = $em->getRepository('IbwJobeetBundle:Category')->getWithJobs();

           foreach($categories as $category) {
               $category->setActiveJobs($em->getRepository('IbwJobeetBundle:Job')->getActiveJobs($category->getId()));
           }

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'categories' => $categories
           ));
       }

   // ...

これが機能するためには、私たちはCategoryクラス、active_jobsに新しいプロパティを追加する必要があります。
For this to work, we have to add a new property to our Category class, the active_jobs:

src/Ibw/JobeetBundle/Entity/Category.php

.. code-block:: php

   class Category
   {
       // ...

       private $active_jobs;

       // ...

       public function setActiveJobs($jobs)
       {
           $this->active_jobs = $jobs;
       }

       public function getActiveJobs()
       {
           return $this->active_jobs;
       }
   }

テンプレートでは、すべてのカテゴリを反復処理し、アクティブジョブを表示する必要があります。
In the template, we need to iterate through all categories and display the active jobs:

src/Ibw/JobeetBundle/Resources/views/Job/index.html.twig

.. code-block:: html+jinja

   <!-- ... -->
   {% block content %}
       <div id="jobs">
           {% for category in categories %}
               <div>
                   <div class="category">
                       <div class="feed">
                           <a href="">Feed</a>
                       </div>
                       <h1>{{ category.name }}</h1>
                   </div>
                   <table class="jobs">
                       {% for entity in category.activejobs %}
                           <tr class="{{ cycle(['even', 'odd'], loop.index) }}">
                               <td class="location">{{ entity.location }}</td>
                               <td class="position">
                                   <a href="{{ path('ibw_job_show', { 'id': entity.id, 'company': entity.companyslug, 'location': entity.locationslug, 'position': entity.positionslug }) }}">
                                       {{ entity.position }}
                                   </a>
                               </td>
                                <td class="company">{{ entity.company }}</td>
                           </tr>
                       {% endfor %}
                   </table>
               </div>
           {% endfor %}
       </div>
   {% endblock %}

結果を制限
----------
Limit the results
-----------------

ホームページジョブリストのために実装する1つの要件がまだあります：私たちは10項目にジョブリストを制限する必要があります。つまり、（）メソッドJobRepository:: getActiveJobsに$ maxのパラメータを追加するために十分に簡単です：
There is still one requirement to implement for the homepage job list: we have to limit the job list to 10 items. That’s simple enough to add the $max parameter to the JobRepository::getActiveJobs() method:

src/Ibw/JobeetBundle/Repository/JobRepository.php

.. code-block:: php

    public function getActiveJobs($category_id = null, $max = null)
    {
        $qb = $this->createQueryBuilder('j')
            ->where('j.expires_at > :date')
            ->setParameter('date', date('Y-m-d H:i:s', time()))
            ->orderBy('j.expires_at', 'DESC');

        if($max) {
            $qb->setMaxResults($max);
        }

        if($category_id) {
            $qb->andWhere('j.category = :category_id')
                ->setParameter('category_id', $category_id);
        }

        $query = $qb->getQuery();

        return $query->getResult();
    }

$ maxのパラメータが含まれるようにgetActiveJobs（）への呼び出しを変更します。
Change the call to getActiveJobs() to include the $max parameter:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $categories = $em->getRepository('IbwJobeetBundle:Category')->getWithJobs();

           foreach($categories as $category)
           {
               $category->setActiveJobs($em->getRepository('IbwJobeetBundle:Job')->getActiveJobs($category->getId(), 10));
           }

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'categories' => $categories
           ));
       }

   // ...

カスタム設定
Custom Configuration
--------------------

JobController、indexAction法では、最大ジョブ数は、カテゴリに対して返さ打ちしました。それは、10制限が設定可能にする方がベターです。 symfonyにおいて、あなたは（パラメータキーが存在しない場合は作成して）パラメータキーの下に、アプリ/ configに/ config.ymlファイルでアプリケーション用のカスタムパラメータを定義できます。
In the JobController, indexAction method, we have hardcoded the number of max jobs returned for a category. It would have been better to make the 10 limit configurable. In Symfony, you can define custom parameters for your application in the app/config/config.yml file, under the parameters key (if the parameters key doesn’t exist, create it):

app/config/config.yml

.. code-block:: yaml

   # ...

   parameters:
       max_jobs_on_homepage: 10

これは、現在のコントローラからアクセスできます。
This can now be accessed from a controller:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

       public function indexAction()
       {
           $em = $this->getDoctrine()->getManager();

           $categories = $em->getRepository('IbwJobeetBundle:Category')->getWithJobs();

           foreach($categories as $category) {
               $category->setActiveJobs($em->getRepository('IbwJobeetBundle:Job')->getActiveJobs($category->getId(), $this->container->getParameter('max_jobs_on_homepage')));
           }

           return $this->render('IbwJobeetBundle:Job:index.html.twig', array(
               'categories' => $categories
           ));
       }

   // ...

動の備品
--------
Dinamic Fixtures
----------------

私達が私達のデータベースでの仕事、非常に少量のを持っているので、今では、何の違いも表示されません。私たちは、フィクスチャにジョブの束を追加する必要があります。
だから、あなたはコピーして、既存のジョブに手で10または20倍を貼り付ける...しかし、もっと良い方法がありますことができます。重複があってもフィクスチャファイルにおいて、悪いです。
For now, you won’t see any difference because we have a very small amount of jobs in our database. We need to add a bunch of jobs to the fixture.
So, you can copy and paste an existing job ten or twenty times by hand… but there’s a better way. Duplication is bad, even in fixture files:

src/Ibw/JobeetBundle/DataFixtures/ORM/LoadJobData.php

.. code-block:: php

   // ...

   public function load(ObjectManager $em)
   {
       // ...

       for($i = 100; $i <= 130; $i++)
       {
           $job = new Job();
           $job->setCategory($em->merge($this->getReference('category-programming')));
           $job->setType('full-time');
           $job->setCompany('Company '.$i);
           $job->setPosition('Web Developer');
           $job->setLocation('Paris, France');
           $job->setDescription('Lorem ipsum dolor sit amet, consectetur adipisicing elit.');
           $job->setHowToApply('Send your resume to lorem.ipsum [at] dolor.sit');
           $job->setIsPublic(true);
           $job->setIsActivated(true);
           $job->setToken('job_'.$i);
           $job->setEmail('job@example.com');

           $em->persist($job);
       }

       // ...
       $em->flush();
   }

   // ...

備品：これで、教義と備品リロードできloadタスクをわずか10のジョブがプログラミングカテゴリのホームページに表示されているかどうか。
You can now reload the fixtures with the doctrine:fixtures:load task and see if only 10 jobs are displayed on the homepage for the Programming category:

.. image:: /images/Day-6-limited-no-of-jobs.png

求人ページを固定します
----------------------
Secure the Job Page
-------------------

ジョブが終了すると、URLを知っていても、それはもうそれにアクセスすることはあってはならない。 ： - （、SELECT idを仕事からトークンWHERE expires_at<NOW（）は、データベース内の実際のidを持つIDを置き換える）期限切れの求人用のURLを試してみてください
/app_dev.php/job/sensio-labs/paris-france/ID/webデベロッパ期限切れ
仕事を表示する代わりに、私たちは404ページにユーザーを転送する必要があります。このために私たちはJobRepositoryで新しい関数を作成します。
When a job expires, even if you know the URL, it must not be possible to access it anymore. Try the URL for the expired job (replace the id with the actual id in your database – SELECT id, token FROM job WHERE expires_at < NOW()):
/app_dev.php/job/sensio-labs/paris-france/ID/web-developer-expired
Instead of displaying the job, we need to forward the user to a 404 page. For this we will create a new function in the JobRepository:
src/Ibw/JobeetBundle/Repository/JobRepository.php

.. code-block:: php

   // ...

       public function getActiveJob($id)
       {
           $query = $this->createQueryBuilder('j')
               ->where('j.id = :id')
               ->setParameter('id', $id)
               ->andWhere('j.expires_at > :date')
               ->setParameter('date', date('Y-m-d H:i:s', time()))
               ->setMaxResults(1)
               ->getQuery();

           try {
               $job = $query->getSingleResult();
           } catch (\Doctrine\Orm\NoResultException $e) {
               $job = null;
           }

           return $job;
       }

は、getSingleResult（）メソッドは、結果が返されない場合にはDoctrine\ ORM\ NoResultException例外がスローされますとDoctrine\ ORM\ NonUniqueResultException複数の結果が返された場合。この方法を使用する場合は、のtry-catchでラップblockandつしか結果が返されることを保証する必要があるかもしれません。
今すぐ新しいリポジトリメソッドを使用するようにJobControllerからshowAction（）を変更します。
The getSingleResult() method throws a Doctrine\ORM\NoResultException exception if no results are returned and a Doctrine\ORM\NonUniqueResultException if more than one result is returned. If you use this method, you may need to wrap it in a try-catch blockand ensure that only one result is returned.
Now change the showAction() from the JobController to use the new repository method:

src/Ibw/JobeetBundle/Controller/JobController.php

.. code-block:: php

   // ...

   $entity = $em->getRepository('IbwJobeetBundle:Job')->getActiveJob($id);

   // ...

あなたが期限切れの仕事を取得しようとした場合さて、あなたは404ページに転送されます。
Now, if you try to get an expired job, you will be forwarded to a 404 page:

.. image:: /images/Day-6-no-job-found.png

つまり、今日のすべてです！私たちは、カテゴリページで再生されますとき私たちは、明日またお会いします。
That’s all for today! We will see you again tomorrow, when we’ll be playing with the category page.

.. include:: common/license.rst.inc
